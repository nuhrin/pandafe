#!/bin/bash
#=============================================================================
#### pnd_loging :
###	Set of functions used to enable good loging and feedback to the user.
##	
#


#	Variables
#=============================================================================

PND_SCRIPT=$(basename $0)
PND_ARGS="$*"
USER=${USER:-$(whoami)}

# Script description (for loging matter)
PND_DESCRIPTION=${PND_DESCRIPTION:-$PND_SCRIPT}



# Check if the script does have a tty connected (else it's useless to display on screen, will just log
PND_IsInteractive() {
	eval $(ps -o tty,pid 2>/dev/null|grep "$$"|awk 'BEGIN{R=1}/pts/{R=0}END{print "return "R}') 2>/dev/null		#fixing those "ps: no controlling terminal"
}
PND_INTERACTIVE=${PND_INTERACTIVE:-$(ps -o tty,pid 2>/dev/null|grep $$|awk 'BEGIN{R=0}/pts/{R=1}END{print R}')} 2>/dev/null #fixing those "ps: no controlling terminal"
# Values :
#  0 - log : there is no tty available
#  1 - Display on screen

# Verbosity
PND_TASK_VERBOSITY=${PND_TASK_VERBOSITY:-1}
# Values :
# 1 - All tasks are separated, while in interactive, only the current task wwill be displayd not their output (but will be loged)
# 0 - while in interactive mode, everything is passed to the screen

# Ident level. Usefull when nesting tasks.
PND_INDENT=${PND_INDENT:-0}

# Get current tty width (for right alignement)
if [ -x /usr/bin/resize ] && PND_IsInteractive;then
	unset COLUMNS
	eval $(/usr/bin/resize)
fi
PND_COLUMNS=${COLUMNS:-${PND_COLUMNS:-80}}


# Name of the function that will parse the output to detect other errors
PND_OUT_CHECK=${PND_OUT_CHECK:-"PND_STD_check"}

# Define if the script should recheck the log before claiming succes
PND_DOUBLE_CHECK=${PND_DOUBLE_CHECK:-1}
# Values :
# 1 - enabled
# 0 - disabled

# Errors counter
PND_ERRORS=0


# 
PND_HEADER=${PND_HEADER:-"PND_SCRIPT PND_ARGS"}

# Allow to know if this is executed within PND_Exec or not
PND_ISEXEC=0

if [ ! -z "$SDK_PATH" ];then
	PND_LOG_DIR="$SDK_PATH/var/log"
	PND_LOG="$PND_LOG_DIR/${PND_SCRIPT}.$(date '+%Y%m%d_%H%M%S').log";
else
	PND_LOG_DIR="/tmp"
	PND_LOG=${PND_LOG:-"$PND_LOG_DIR/${PND_SCRIPT}.log"}
fi


#	Utilities functions
#=============================================================================

##############################################################################
###
##  Output checker
PND_STD_check() {
awk 'BEGIN{R=0}END{exit R}
/cannot open display/||/unary operator expected/||/No such file or directory/||/command not found/{R=1}
{IGNORECASE=1}
!/gpg-error/&&/ERROR/||/FAILED/{R=1}
{IGNORECASE=0}'
}

##############################################################################
###
##  Display $1 $2x times, to ident titles
PND_Pad() {
	local x="$1"
	local m="$2"
	local i=0

	while [ $i -le $m ];do
		printf "$x"
		i=$(($i+1))
	done
}

##############################################################################
###
##  Current date and time
PND_Date() {
	date '+%Y%m%d_%Hh%Mm%S'
}

PND_Time() {
	date '+%Hh%Mm%S'
}

##############################################################################
###
##  set a return-code
PND_setReturn() {
	return $1
}

#####################################################################################
### 
##  A usefull counter ....
PND_countTo() { #int
	cnti=${2:-1}
	cntc=$1
	while [ $cnti -le $cntc ];do
		echo $cnti;
		i=$(( $cnti + 1 ))
	done
}

#####################################################################################
### 
##  Merge list separated with ":" not dup in the result
PND_mergeList() {
	local R=""
	local m=0
	if [ $# -gt 1 ];then
		R=$1
		for n in $(echo "$2"|sed 's/:/ /g');do
			m=0
			for i in $(echo "$R"|sed 's/:/ /g');do
				if [ "$i" = "$n" ];then
					m=1;
				fi
			done
			if [ $m -eq 0 ];then
				R="$R:$n"
			fi
		done
		echo $R
	elif [ $# -eq 1 ];then
		echo "$1"
	else
		echo ERROR
		return 1
	fi
}

#####################################################################################
### 
##  Built the intersection of 2 lists
PND_intersecList() {
	if [ $# -gt 1 ];then
		R=""
		for n in $(echo "$1"|sed 's/:/ /g');do
			for m in $(echo "$2"|sed 's/:/ /g');do
				if [ "$n" = "$m" ];then
					p=0
					for i in $(echo "$R"|sed 's/:/ /g');do
						if [ "$i" = "$n" ];then
							p=1;
						fi
					done
					if [ $p -eq 0 ];then
						R="$(echo "$R:$n"|sed 's/^://')"
					fi
				fi
			done
		done
		echo $R
	elif [ $# -eq 1 ];then
		echo "$1"
	else
		echo ERROR
		return 1
	fi
}

#####################################################################################
### 
##  Remove dup from *PATH
PND_cleanPath() {
	local RES=""
	local f=1
	for p in $(echo $1|sed 's/:/ /g');do
		f=0
		for i in $(echo $RES|sed 's/:/ /g');do
			if [[ $p = $i ]];then
				f=1
			fi
		done
		if [ $f -eq 0 ];then
			RES=$(echo "$RES:$p"|sed 's/^://')
		fi
	done
	echo $RES
}

##############################################################################
###
##  Check current user.
PND_userMatch() {
	case $USER in
	$1)	return 0;;
	*)	return 1;;
	esac
}
PND_userIs() {
	case $USER in
	$1)	return 0;;
	*)
		PND_Error "Vous ne pouvez pas passez cette commande avec cet utilisateur ($USER!~$1)"
	;;
	esac
	return 1;
}

PND_countMyProcess() {
	ps -o args -u $USER|awk 'BEGIN{c=0}END{print c}/'"$1"'/&&!/awk/{c=c+1}'
}

PND_prefix() {
	while read line;do
		echo "[$1] - $line"
	done
}

#			Mail handling
#=============================================================================

##############################################################################
###
##  Send a mail
PND_Mail() {
	{
		echo "To: $PND_MAILTO"
		echo "From: PND toolchain <$USER@$(hostname)>"
		echo "Subject: $*"
		while read line;do echo "$line";done
	}|/usr/sbin/sendmail -i -t
}

##############################################################################
###
##  Send a standard error mail
PND_MailError() {
	RC=$?
	if [ $PND_INTERACTIVE -eq 0 ];then
		PND_Log  "Sending Email alert to $PND_MAILTO"
		PND_Mail "ALERT - Failure $PND_SCRIPT $PND_ARGS" <<ENDMAIL
$(basename $0) failed at "$PND_DESCRIPTION"
See $PND_LOG for more information.

Digest:
$(egrep -i "error|warning|failed" $PND_LOG)

ENDMAIL
	else
		PND_Error "Error while \"$PND_DESCRIPTION\""
	fi
	return $RC
}

#			  Log Handling
#=============================================================================


##############################################################################
###
##  Create the logfile with it's initial header
PND_Start() {
	if [ ! -e $PND_LOG ];then
		touch $PND_LOG
	fi
	{
	echo "======================================================================================="
	for v in $PND_HEADER;do
		printf "%-15s : %s\n" "$v"  "$(eval "echo \${$v:-'<unset>'}")"
	done
	echo "======================================================================================="
	}>$PND_LOG
}

##############################################################################
###
##  End of the script, check for errors eventually send a mail on error
PND_Stop() {
	local RC=$?
	if [ $PND_DOUBLE_CHECK -eq 1 ] && [ -f $PND_LOG ];then
		RC=$(( $RC + $(awk 'BEGIN{R=0}END{print R}$2=="ERROR"{R=R+1}'<$PND_LOG) ))
	fi
	if [ $RC -gt 0 ] && [ ! -z "$PND_MAILTO" ];then
		PND_MailError
	fi
	{
	echo "======================================================================================="
	echo "Return code is : $RC"
	}>>$PND_LOG
	return $RC
}

PND_LogDateFormat=PND_Date
##############################################################################
###
##  Write to logfile
PND_Log() {
	local STATUS=$1;
	local DO_LOG_SEP=0
	case $STATUS in
	FEED)	return;;
	SCREEN)	[ $PND_INTERACTIVE -gt 0 ] && return;shift;;
	UP|DOWN|UNKNOWN|info|INFO|WARNING|FAILED|ERROR|START|SUCCESS)	shift;;
	*)	STATUS=INFO;;
	esac;
	if [ $PND_TASK_VERBOSITY -eq 1 ];then
		case $ACTION in 
		UP|DOWN|UNKNOWN|START|FAILED|SUCCESS) DO_LOG_SEP=1;;
		esac
	fi
	if [ ! -e $PND_LOG ];then
		if [ ! -d $(dirname $PND_LOG) ];then
			mkdir -p $(dirname $PND_LOG)
		fi
		touch $PND_LOG
	fi
	if [ $PND_ISEXEC -eq 1 ];then	# Nested into a PND_Exec, pass to it what to log
		echo $STATUS "$*"	# (you dont want to have 2 process loging in the same files)
	elif [ $DO_LOG_SEP -eq 1 ];then
		local Y=$(echo "$*"|sed "s/[^ ].*//"|wc -c)
		local X="$(PND_Pad "=" $Y) $(echo "$*"|sed "s/^ *//g")"
		printf "["$($PND_LogDateFormat)" %7s ]=%s %s\n" "$STATUS" "$X" "$(PND_Pad "=" $((66-$(echo "$X"|wc -c))))" >>$PND_LOG 2>&1
	else
		printf "["$($PND_LogDateFormat)" %7s ]   %s\n" "$STATUS" "$*" >>$PND_LOG 2>&1
	fi
}

##############################################################################
###
##  PND_Printf ACTION_TYPE PATTERN Arguments...
#    Use $PND_INTERACTIVE and $PND_TASK_VERBOSITY to know if that have to be loged
#    or displayed. It also react to ACTION_TYPE to for fancy effects ;)
PND_Printf() {
	local ACTION="INFO"
	local PATTERN="%s\n"
	local C="\r"
	local COLOR=""
	local X=""
	case "$1" in
	WARNING|FEED|START|ERROR|SUCCESS|SCREEN|INFO|UNKNOWN|FAILED)
		ACTION=$1;shift;;
	esac
	if [ "$#" -gt 1 ];then
		PATTERN="$1"
		shift
	fi
	if [[ "$ACTION" == "INFO" ]] && [ "$#" -gt 1 ];then
		case "$1" in			# In case type is after the patern
		WARNING|FEED|START|ERROR|SUCCESS|SCREEN|INFO|UNKNOWN|FAILED)
			ACTION="$1";shift;;
		esac
	fi
	if [ $PND_INTERACTIVE -eq 1 ] && [[ $ACTION = START ]];then
		PATTERN=$(echo "$PATTERN"|sed 's#\\n$##')
	elif [ $PND_INTERACTIVE -eq 1 ] && [[ $ACTION = SUCCESS ]];then
		COLOR="\\033[32m"
		X=$(printf "\033[$(($PND_COLUMNS - 10))G[$COLOR%7s\033[m]\n" "$ACTION")
		PATTERN="%s$X\n"
	elif [ $PND_INTERACTIVE -eq 1 ] && ( [[ $ACTION = FAILED ]] || [[ $ACTION = ERROR ]] );then
		COLOR="\\033[31m"
		X=$(printf "\033[$(($PND_COLUMNS - 10))G[$COLOR%7s\033[m]\n" "$ACTION")
		PATTERN="%s$X\n"
	fi

	case $PND_INTERACTIVE in
	0)	PND_Log $ACTION "$*";;
	1)	if [[ "$ACTION" = "FEED" ]];then
			if [ $PND_ISEXEC -eq 1 ];then
				printf "." >&3
			else
				printf "."
			fi
		elif [[ "$ACTION" = "SCREEN" ]];then
			if [ $PND_ISEXEC -eq 1 ];then
				printf "$PATTERN" "$*" >&3
			else
				printf "$PATTERN" "$*"
			fi
			if [ $PND_TASK_VERBOSITY -eq 1 ];then
				PND_Log $ACTION "$*"
			fi
		elif [ $PND_TASK_VERBOSITY -eq 1 ] && ( [[ "$ACTION" = "INFO" ]] || [[ "$ACTION" = "WARNING" ]] );then
			PND_Log $ACTION "$*"
		else
			if [[ "$PND_LAST_PRINT" = "START" ]] && [[ "$ACTION" = "START" ]];then
				C="\n\r"
			fi
			if [ $PND_TASK_VERBOSITY -eq 1 ];then
				PND_Log $ACTION "$*"
			fi
			if [ $PND_ISEXEC -eq 1 ];then
				printf "$C%${PND_INDENT}s$PATTERN" "" "$*" >&3
			else
				printf "$C%${PND_INDENT}s$PATTERN" "" "$*"
			fi
			export PND_LAST_PRINT=$ACTION
		fi;;
	2)	case $PATTERN in
		*\n);;
		*)	PATTERN="$PATTERN\n";;
		esac
		printf "%s %${PND_INDENT}s$PATTERN" "$ACTION" "" "$*";;
	esac
}


##############################################################################
###
##  little brothers of the previous one
PND_Print() {
	ACTION="INFO"
	case "$(echo $1|awk '{print $1}')" in
	FEED)	ACTION=FEED;;
	START)	ACTION=START;;
	ERROR*)	ACTION=ERROR;;
	FAILED*)ACTION=FAILED;;
	SUCCESS)ACTION=SUCCESS;;
	SCREEN)	ACTION=SCREEN;;
	INFO)	ACTION=INFO;;
	WARNING)ACTION=WARNING;;
	UNKNOWN)ACTION=UNKNOWN;;
	esac
	T=$(echo "$*"|sed 's/^'$ACTION'[ ]\{0,1\}//')
	PND_Printf "$ACTION" "%s\n" "$T"
}


##############################################################################
###
##  Alias to PND_Printf ERROR ...
PND_Error() {
	export PND_ERRORS=$(( $PND_ERRORS + 1 ))
	local T=$(printf "$*\n"|sed 's/^ERROR[ ]\{0,1\}//')
	if echo $line|awk 'BEGIN{R=1}END{exit R}/^FAILED/{R=0}';then
		local T=$(printf "$*\n"|sed 's/^FAILED[ ]\{0,1\}//')
		PND_Printf FAILED "%s\n" "$T"
	elif echo $line|awk 'BEGIN{R=1}END{exit R}/^SCREEN/{R=0}';then
		local T=$(printf "$*\n"|sed 's/^SCREEN[ ]\{0,1\}//')
		PND_Printf SCREEN "%s\n" "$T"
	else
		PND_Printf ERROR "%s\n" "$T"
	fi
	return 128
}

##############################################################################
###
##  Output to screen something from stdin
PND_Cat() {
	while read line;do
		PND_Print SCREEN "$line"
	done
}

##############################################################################
###
##  Start it's arguments and parse it's output t find errors
#   the output is then displayed on screen or logged
PND_Exec() {
	local CMD="$*"
	{
	if [ $PND_ISEXEC -eq 0 ];then
		PND_ISEXEC=1
		exec 3>&1		# 
	fi
	export PND_INTERACTIVE=2
	$* 2>&1
	RES=$(( $? + $PND_ERRORS ))
	echo "<result>$RES</result>"
	PND_ISEXEC=0
	exec 3>&-
	}|{
	while read line;do
		if echo "$line"|grep -q "<result>.*</result>";then
			return $(( $(echo $line|sed 's/<[^>]*>//g') + $PND_ERRORS ))
		elif ! echo "$line"| $(eval $PND_OUT_CHECK); then
			PND_Error "$line";
		else
			PND_Print "$line";
		fi
	done
	return $PND_ERRORS
	}
}

#                      Tasks Display
#=============================================================================

##############################################################################
###
##  Start a task in the log
PND_BeginTask() {
	PND_TASK_NAME="$*"
	PND_Printf START "%s" "$PND_TASK_NAME"
	export PND_INDENT=$(( $PND_INDENT + 4 ))
}

##############################################################################
###
##  Will display a new dot on a line to show the task is still alive
PND_TaskFeedBack() {
	PND_Printf FEED "%s" "."
}

##############################################################################
###
##  Finish the task in the log. The return code depend on first argument and 
#    previous return code.
PND_EndTask() {
	local RC=$?
	local R=""
	local STATUS=""
	local COLOR=""
	local X=""
	PND_INDENT=$(( $PND_INDENT - 4 ))
	if [ $# -gt 0 ];then
		R=$1
		if [[ $R = "SUCCESS" ]];then
			RC=0
		else
			RC=1
		fi
	else
		if [ $RC -eq 0 ];then 
			STATUS=SUCCESS
		else
			STATUS=FAILED
		fi
	fi
	PND_Printf $STATUS "%s\n" "$PND_TASK_NAME"
	unset PND_TASK_NAME PND_TASK_ID
	return $RC
}

##############################################################################
###
##  Wait for a test command to return succes (o)
#    
PND_WaitFor() {
	[ $# -gt 0 ]||return 1
	local l_test="$1"
	local l_name=${2:-"Wait succes of $1"}
	local l_cnt=${3:-12}
	local l_sleep=${4:-10}
	local C=0
	PND_TASK_ID="PND_WaitFor($l_test)"
	#PND_BeginTask $l_name
	while [ $C -lt $l_cnt ] && ! eval $l_test;do
		sleep $l_sleep;C=$(($C + 1));	#PND_TaskFeedBack
	done
	[ $C -lt $l_cnt ]
	#PND_EndTask
}

#                      Tasks Management
#=============================================================================
# To use this, you'll need to create a function :
# CB_PND_List_Task() {
# cat <<ENDCB
# function-name1 description1 
# function-name2 description2 is very long
# ENDCB
# }
#
# This function will be used to know 
# - the functions to run
# - in wich order
# - what description to display for these

##############################################################################
###
##  Show help
__PND_Task_usage() {
	local x=$(CB_PND_List_Task|awk '{print $1}');x=$(echo $x|sed 's/ / | /g')
	echo Usage :
	echo
	echo "$0 [ -help | -list | -only ]  [ $x ]"
	echo
	echo Parameters :
	echo
	echo "-help			Show this help screen"
	echo "-list			List all the task currently available"
	echo "-only			Disable the auto next file"
	echo
	echo Available Tasks :
	echo
	CB_PND_List_Task
	return 100
}

##############################################################################
###
##  Will start the task-list and continu on failure to repport every error found
PND_StartTasks() {
	local i=1
	local o=0
	local MAX=1
	local R=0
	while [ "$#" -gt 0 ];do
		case "$1" in
		-help|-h*|-H*)
			__PND_Task_usage|PND_Cat
			return 0;;
		-list|-l*|-L*)
			CB_PND_List_Task|PND_Cat
			return 0;;
		-only)	o=1;;
		-*)
			PND_Error "'$1' is not a valid argument"
			__PND_Task_usage|PND_Cat
			return 10;;
		*)
			# Consider $1 as the function-name and get the task number (lineno)
			i=$(CB_PND_List_Task|grep -n $1|awk -F: '{print $1;exit}')
			i=${i:-$(echo $1|sed 's/[^0-9]*//g')}
			if [[ "x$i" = "x" ]];then
				PND_Error "'$1' is not a valid task";
				echo
				__PND_Task_usage|PND_Cat
				return 20
			fi;;
		esac;
		shift;
	done

	MAX=$(CB_PND_List_Task|wc -l)
	[ $o -eq 1 ] && MAX=$i	# if only is set, set max to min so only that task will be used

	FAILED=""
	while [ $i -le $MAX ];do
		PND_TASK_ID=$(CB_PND_List_Task|awk 'NR=='$i'{print $1}')
		PND_TASK_NAME=$(CB_PND_List_Task|awk 'NR=='$i'{print substr($0,length($1)+2)}')
		PND_BeginTask $PND_TASK_NAME
		PND_Exec $PND_TASK_ID
		PND_EndTask
		R=$?
		if [ "$R" -ne 0 ];then
			FAILED="$FAILED $PND_TASK_ID"
		fi
		i=$(( $i + 1 ))
	done
	return $R
}


#=============================================================================

#export PATH=$(PND_cleanPath $PATH)
#export PND_LOG_DIR PND_MAILTO PND_LOG PND_OUT_CHECK PND_INTERACTIVE
#export PND_ERRORS PND_DOUBLE_CHECK PND_HEADER PND_PARAMETER_FILE PND_OUT_CHECK PND_TASK_VERBOSITY PND_ACTION PND_DESCRIPTION PND_SCRIPT PND_COLUMNS PATH
